/**
 * @Authors: Ali & Singh
 * Implementation of the SHA-3 cryptographic hash function.
 *
 */
public class Sha3 {
    // Constants
    public static final long BYTE_MASK = 0xFF;
    public static int KECCAKF_ROUNDS = 24;

    long[] keccakf_rndc = {
            0x0000000000000001L, 0x0000000000008082L, 0x800000000000808AL,
            0x8000000080008000L, 0x000000000000808BL, 0x0000000080000001L,
            0x8000000080008081L, 0x8000000000008009L, 0x000000000000008AL,
            0x0000000000000088L, 0x0000000080008009L, 0x000000008000000AL,
            0x000000008000808BL, 0x800000000000008BL, 0x8000000000008089L,
            0x8000000000008003L, 0x8000000000008002L, 0x8000000000000080L,
            0x000000000000800AL, 0x800000008000000AL, 0x8000000080008081L,
            0x8000000000008080L, 0x0000000080000001L, 0x8000000080008008L
    };

    int[] keccakf_rotc = {
            1, 3, 6, 10, 15, 21, 28, 36, 45, 55,
            2, 14, 27, 41, 56, 8, 25, 43, 62, 18,
            39, 61, 20, 44
    };

    int[] keccakf_piln = {
            10, 7, 11, 17, 18, 3, 5, 16, 8, 21,
            24, 4, 15, 23, 19, 13, 12, 2, 20, 14,
            22, 9, 6, 1
    };

    // Bitwise rotation operation for 64-bit integers
    static long ROTL64(long x, long y) {
        var u = (((x) << (y)) | ((x) >>> (64 - (y))));
        if (64 - y < 0) {
            throw new RuntimeException("y out of valid range for uint");
        }
        return u;
    }

    // Print hexadecimal representation of byte array
    public static void phex(byte[] Xs) {
        for (var x : Xs) System.out.printf("%02X ", x);
        System.out.println();
    }

    // Initialize SHAKE128 context
    static sha3_ctx_t shake128_init(sha3_ctx_t c) {
        sha3_init(c, 16);
        return c;
    }

    // Initialize SHAKE256 context
    static sha3_ctx_t shake256_init(sha3_ctx_t c) {
        sha3_init(c, 32);
        return c;
    }

    // Perform Keccak-f permutation
    static void sha3_keccakf(sha3_ctx_t c) {
        // Use the class-level variables instead of locally defined ones
        Sha3 sha3 = new Sha3();
        long[] keccakf_rndc = sha3.keccakf_rndc;
        int[] keccakf_rotc = sha3.keccakf_rotc;
        int[] keccakf_piln = sha3.keccakf_piln;

        long[] st = c.byWord(); // Retrieve the state array

        long t;
        long[] bc = new long[5];

        for (int r = 0; r < KECCAKF_ROUNDS; r++) {
            // Theta step
            for (int i = 0; i < 5; i++) {
                bc[i] = st[i] ^ st[i + 5] ^ st[i + 10] ^ st[i + 15] ^ st[i + 20];
            }

            // Rho and Pi steps
            t = bc[1];
            for (int i = 0; i < 25; i++) {
                int index = keccakf_piln[i];
                bc[0] = st[index];
                st[index] = Long.rotateLeft(st[keccakf_piln[(i + 1) % 25]], keccakf_rotc[i]);
            }

            // Chi step
            for (int j = 0; j < 25; j += 5) {
                System.arraycopy(st, j, bc, 0, 5);
                for (int i = 0; i < 5; i++) {
                    st[j + i] ^= (~bc[(i + 1) % 5]) & bc[(i + 2) % 5];
                }
            }
            st[0] ^= keccakf_rndc[r];
        }

        // Reverse byte order
        for (int i = 0; i < 25; i++) {
            st[i] = Long.reverseBytes(st[i]);
        }
        c.setWord(st);
    }


    // Initialize SHA-3 context
    static void sha3_init(sha3_ctx_t c, int mdlen) {
        c.setWord(new long[25]);
        c.mdlen = mdlen;
        c.rsiz = 200 - 2 * mdlen;
        c.pt = 0;
    }

    // Update SHA-3 context with input data
    static void sha3_update(sha3_ctx_t c, byte[] data, long len) {
        int j = c.pt;
        for (int i = 0; i < len; i++) {
            c.b[j++] ^= data[i];
            if (j >= c.rsiz) {
                sha3_keccakf(c);
                j = 0;
            }
        }
        c.pt = j;
    }

    // Finalize SHA-3 computation and output the hash
    static void sha3_final(byte[] md, sha3_ctx_t c) throws IllegalArgumentException {
        if (md == null) {
            throw new IllegalArgumentException("sha3_final: md is null");
        }

        c.b[c.pt] ^= 0x06;
        c.b[c.rsiz - 1] ^= 0x80;
        sha3_keccakf(c);

        if (c.mdlen >= 0) System.arraycopy(c.b, 0, md, 0, c.mdlen);
    }

    // Compute SHA-3 hash
    public static void sha3(byte[] in, long inlen, byte[] md, int mdlen) {
        sha3_ctx_t sha3ctx = new sha3_ctx_t();
        sha3_init(sha3ctx, mdlen);
        sha3_update(sha3ctx, in, inlen);
        sha3_final(md, sha3ctx);
    }

    // Update SHAKE context with input data
    static void shake_update(sha3_ctx_t c, byte[] data, long len) {
        sha3_update(c, data, len);
    }

    // Squeeze output from SHAKE context
    static void shake_out(sha3_ctx_t c, byte[] out, long len) {
        int j = c.pt;
        for (int i = 0; i < len; i++) {
            if (j >= c.rsiz) {
                sha3_keccakf(c);
                j = 0;
            }
            out[i] = c.b[j++];
        }
        c.pt = j;
    }

    // SHA-3 context structure
    static class sha3_ctx_t {
        public byte[] b;
        public int pt, rsiz, mdlen;

        sha3_ctx_t() {
            this.b = new byte[200];
        }

        public long[] byWord() {
            long[] words = new long[b.length / 8];
            for (int i = 0; i < 25; i++) {
                var v = new long[8];
                for (int j = 0; j < 8; j++) {
                    v[j] = this.b[i * 8 + j] & 0xFFL;
                }

                words[i] = v[7] |
                        (v[6] << 8) |
                        (v[5] << 16) |
                        (v[4] << 24) |
                        (v[3] << 32) |
                        (v[2] << 40) |
                        (v[1] << 48) |
                        (v[0] << 56);
            }
            return words;
        }

        public void setWord(long[] words) {
            for (int w = 0; w < words.length; w++) {
                long word = words[w];
                for (int i = 0; i < 8; i++) {
                    b[w * 8 + i] = (byte) (((word >>> (7 - i) * 8)) & 0xFF);
                }
            }
        }

        public void setBytes(byte[] bytes) {
            if (this.b.length < bytes.length) {
                this.b = new byte[bytes.length];
            }
            System.arraycopy(bytes, 0, this.b, 0, bytes.length);
        }
    }


}


    // Left encoding of a BigInteger
    public static byte[] left_encode(BigInteger x) {
        byte[] b = x.toByteArray();
        return appendBytes(new byte[]{(byte) b.length}, b);
    }

    // Left encoding of a byte array
    public static byte[] left_encode(byte[] b) {
        return appendBytes(new byte[]{(byte) b.length}, b);
    }


        static public byte[] encode_string(BigInteger S) {
            return encode_string(S.toByteArray());
        }



            // Symmetric encryption using KMACXOF256
            public static byte[] symmetricEncrypt(byte[] m, byte[] pw) {
                byte[] z = randomBytes();
                byte[] ke_ka = KMACXOF256(
                        appendBytes(z, pw),
                        "".getBytes(),
                        1024,
                        "S".getBytes());
                byte[] ke = Arrays.copyOfRange(ke_ka, 0, 64);
                byte[] ka = Arrays.copyOfRange(ke_ka, 64, 128);
                byte[] c = KMACXOF256(ke, "".getBytes(), m.length * 8, "SKE".getBytes());
                xor(c, m);
                byte[] t = KMACXOF256(ka, m, 512, "SKA".getBytes());
                byte[] symmetricCryptogram = appendBytes(z, c, t);
                return symmetricCryptogram;
            }

            // Symmetric decryption using KMACXOF256
            public static byte[] symmetricDecrypt(byte[] zct, byte[] pw) {
                byte[] z = Arrays.copyOfRange(zct, 0, 64);
                byte[] c = Arrays.copyOfRange(zct, 64, zct.length - 64);
                byte[] t = Arrays.copyOfRange(zct, zct.length - 64, zct.length);
                byte[] ke_ka = KMACXOF256(appendBytes(z, pw), "".getBytes(), 1024, "S".getBytes());
                byte[] ke = Arrays.copyOfRange(ke_ka, 0, 64);
                byte[] ka = Arrays.copyOfRange(ke_ka, 64, 128);
                byte[] m = xor(KMACXOF256(ke, "".getBytes(), c.length * 8, "SKE".getBytes()), c);
                byte[] tPrime = KMACXOF256(ka, m, 512, "SKA".getBytes());
                if (Arrays.equals(tPrime, t)) {
                    return m;
                } else {
                    throw new IllegalArgumentException("Decryption failed: authentication tag does not match");
                }
            }

                // Generate random bytes
                private static byte[] randomBytes() {
                    SecureRandom random = new SecureRandom();
                    byte[] bytes = new byte[512 / 8];
                    random.nextBytes(bytes);
                    return bytes;
                }


    public static byte[] xor(byte[] X, byte[] Y) {
        for (int i = 0; i < Math.min(X.length, Y.length); i++) {
            X[i] ^= Y[i];
        }
        return X;
    }

